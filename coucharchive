#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2016 Adrien Verg√©
# All rights reserved

import argparse
import configparser
from datetime import datetime
import fileinput
from io import BytesIO
import multiprocessing
import os
import random
import re
import shutil
import socket
import string
import subprocess
import tarfile
import tempfile
import threading
import time
from urllib.parse import quote, urlparse, urlsplit, urlunsplit
import urllib.request

import couchdb


class CouchDBInstance(object):
    def __init__(self, erlang_node, standalone_server=False):
        self.erlang_node = erlang_node
        self.tempdir = tempfile.TemporaryDirectory(prefix='coucharchive-')
        self.thread = None
        self.url = None
        self.standalone_server = standalone_server

        self._setup()

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if self.thread is not None:
            self.stop()

    @property
    def confdir(self):
        return self.tempdir.name + '/etc'

    @property
    def datadir(self):
        return self.tempdir.name + '/data'

    def _random_credential(self):
        return 'root', ''.join(
            random.choice(string.ascii_letters + string.digits)
            for _ in range(10))

    def _two_unused_ports(self):
        s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s1.bind(('localhost', 0))
        _, port1 = s1.getsockname()
        s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s2.bind(('localhost', 0))
        _, port2 = s2.getsockname()
        s1.close()
        s2.close()
        return port1, port2

    def _setup(self):
        os.mkdir(self.confdir)
        os.mkdir(self.confdir + '/local.d')
        os.mkdir(self.datadir)

        self.creds = self._random_credential()
        self.ports = self._two_unused_ports()

        for file in ('vm.args', 'default.ini', 'local.ini'):
            shutil.copy('/etc/couchdb/' + file, self.confdir + '/' + file)

        for line in fileinput.input(self.confdir + '/vm.args', inplace=True):
            if re.match(r'^-name \S+$', line):
                print('-name ' + self.erlang_node)
            else:
                print(line, end='')

        with open(self.confdir + '/local.d/coucharchive.ini', 'w') as f:
            f.write('[chttpd]\n'
                    'port = %d\n' % self.ports[0] +
                    '\n'
                    '[httpd]\n'
                    'port = %d\n' % self.ports[1] +
                    '\n'
                    '[couchdb]\n'
                    'database_dir = %s\n' % self.datadir +
                    'view_index_dir = %s\n' % self.datadir +
                    'max_dbs_open = 2000\n'
                    '\n'
                    '[cluster]\n'
                    'q=1\n'  # ideal for a small, 1-node setup
                    'n=1\n'
                    '\n'
                    '[admins]\n'
                    '%s = %s\n' % self.creds)

    def start(self):
        env = dict(os.environ,
                   COUCHDB_VM_ARGS=self.confdir + '/vm.args',
                   COUCHDB_INI_FILES=(self.confdir + '/default.ini ' +
                                      self.confdir + '/local.ini ' +
                                      self.confdir + '/local.d'))
        log = open(self.tempdir.name + '/log', 'w')

        class CouchDBRunnerThread(threading.Thread):
            def __init__(self):
                super().__init__()
                self.process = None

            def run(self):
                self.process = subprocess.Popen('couchdb', env=env,
                                                stdout=log, stderr=log)
                self.process.wait()

            def terminate(self):
                self.process.terminate()

        self.thread = CouchDBRunnerThread()
        self.thread.start()

        self.url = 'http://%s:%s@localhost:%d' % (self.creds + self.ports[:1])

        if self.standalone_server:
            return

        for i in range(25):
            if not self.thread.is_alive():
                raise Exception('CouchDB process died')
            try:
                self.version = (urllib.request.urlopen('http://localhost:%d'
                                                       % self.ports[0])
                                .read().decode('utf-8'))
                if '"couchdb":"Welcome"' in self.version:
                    return

                self.thread.terminate()
                raise Exception('CouchDB answered: %s' % self.version)
            except urllib.error.URLError:
                time.sleep(0.2)

        self.thread.terminate()
        raise Exception('CouchDB server does not answer after 5 seconds')

    def stop(self):
        print('Terminating local CouchDB instance')
        self.thread.terminate()
        self.thread.join()
        self.thread = None


def replicate_couchdb_server(source_url, target_url, ignore_dbs=[]):
    while source_url.endswith('/'):
        source_url = source_url[:-1]
    while target_url.endswith('/'):
        target_url = target_url[:-1]

    ignore_dbs += ('_global_changes', '_metadata', '_replicator')
    all_dbs = [db for db in list(couchdb.Server(source_url))
               if db not in ignore_dbs]

    todos = [(source_url, target_url, db) for db in all_dbs]

    pool = multiprocessing.Pool(processes=16)
    try:  # see https://stackoverflow.com/a/25791961
        list(pool.imap_unordered(replicate_one_database, todos))
    except Exception as e:
        print('A replication failed, stopping...')
        pool.close()
        pool.terminate()
        raise
    else:
        pool.close()
        pool.join()


def replicate_one_database(args):
    timeout = 3

    source_url, target_url, db = args

    source = couchdb.Server(source_url)
    target = couchdb.Server(target_url)

    source_host = (urlparse(source_url).netloc
                   .rsplit('@', 1)[-1].rsplit(':', 1)[0])
    source_is_local = (source_host == 'localhost' or
                       source_host == '127.0.0.1' or source_host == '::1')

    try:
        target.create(db)
    except couchdb.http.PreconditionFailed as e:
        if e.args[0][0] == 'file_exists' and db in ('_users',):
            pass
        else:
            print(db)
            raise

    server = source if source_is_local else target
    server.replicate(source_url + '/' + db, target_url + '/' + db)

    source_db = couchdb.Database(source_url + '/' + db)
    target_db = couchdb.Database(target_url + '/' + db)

    while True:
        try:
            target_db.security = source_db.security
            break
        except couchdb.http.ServerError as e:
            if timeout == 0:
                if e.args[0][1][1] in ('no_majority', 'no_ring'):
                    print('Retry with a greater ulimit '
                          '(e.g. `ulimit -n 8192`)')
                raise
            time.sleep(1)
            timeout =- 1

    while True:
        source_len, target_len = len(source_db), len(target_db)
        if source_len == target_len:
            break
        elif timeout == 0:
            raise Exception(
                '%s: replicated database has %d docs, source has %d'
                % (db, target_len, source_len))
        time.sleep(1)
        timeout =- 1

    print('%s: done' % db)


def dump(source, filename, ignore_dbs=[]):
    erlang_node = 'coucharchive-%s@localhost' % ''.join(
        random.choice(string.ascii_letters + string.digits) for _ in range(10))

    with CouchDBInstance(erlang_node) as local_couchdb:
        local_couchdb.start()
        print('Launched CouchDB instance at %s' % local_couchdb.url)

        replicate_couchdb_server(source, local_couchdb.url,
                                 ignore_dbs=ignore_dbs)

        local_couchdb.stop()

        print('Creating backup archive at %s' % filename)
        with tarfile.open(filename, 'w:gz') as tar:
            tar.add(local_couchdb.confdir, arcname='etc')
            tar.add(local_couchdb.datadir, arcname='data')

            file = tarfile.TarInfo('erlang_node_name')
            file.size = len(erlang_node)
            tar.addfile(file, BytesIO(erlang_node.encode('utf-8')))

            info = (
                'CouchDB backup made on %s\n' % datetime.now().isoformat() +
                'with CouchDB version %s\n' % local_couchdb.version
            ).encode('utf-8')
            file = tarfile.TarInfo('info')
            file.size = len(info)
            tar.addfile(file, BytesIO(info))


def load(target, filename, standalone_server=False, ignore_dbs=[]):
    if not os.path.isfile(filename):
        raise Exception('File "%s" does not exist' % filename)

    with tarfile.open(filename) as tar, \
            tempfile.TemporaryDirectory(prefix='coucharchive-') as tmp:
        print('Extracting backup archive from %s' % filename)
        tar.extractall(path=tmp)

        if os.path.isfile(tmp + '/erlang_node_name'):
            with open(tmp + '/erlang_node_name', 'r') as f:
                erlang_node = f.read().strip()
        else:  # for archives made before coucharchive 1.2.1
            erlang_node = 'coucharchive@localhost'

        with CouchDBInstance(erlang_node) as local_couchdb:
            os.rmdir(local_couchdb.datadir)
            os.rename(tmp + '/data', local_couchdb.datadir)

            local_couchdb.start()
            print('Launched CouchDB instance at %s' % local_couchdb.url)

            if standalone_server:
                try:
                    time.sleep(365 * 24 * 3600)
                except KeyboardInterrupt:
                    pass
            else:
                replicate_couchdb_server(local_couchdb.url, target,
                                         ignore_dbs=ignore_dbs)


def couchdb_url(url, username, password):
    parts = list(urlsplit(url))
    parts[1] = '%s:%s@%s' % (quote(username, safe=[]),
                             quote(password, safe=[]),
                             parts[1])
    return urlunsplit(parts)  # http://user:pass@server/db/


def main():
    # Get action and archive file from command line
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--config', dest='config_file', required=True,
                        action='store', help='path to config file')
    subparsers = parser.add_subparsers(dest='action')
    dump_parser = subparsers.add_parser('dump')
    dump_parser.add_argument('-o', '--output-file', dest='output_file',
                             required=True, action='store',
                             help='path to archive to create')
    load_parser = subparsers.add_parser('load')
    load_parser.add_argument('-i', '--input-file', dest='input_file',
                             required=True, action='store',
                             help='path to archive to read')
    load_parser.add_argument('--standalone-server', action='store_true',
                             help='load archive in a standalone CouchDB '
                                  'server but do not replicate')
    load_parser = subparsers.add_parser('replicate')
    load_parser.add_argument('--source', dest='source', required=True,
                             action='store',
                             help='source CouchDB server to replicate')
    args = parser.parse_args()

    # Get database server info using the config file
    config = configparser.ConfigParser()
    config.read(args.config_file)
    url = couchdb_url(config['database']['url'],
                      config['database'].get('username', 'root'),
                      config['database'].get('password', ''))

    ignore_dbs = []
    if 'replication' in config.sections():
        ignore_dbs = config['replication'].get('ignore_dbs', '').split(',')
        ignore_dbs = [db.strip() for db in ignore_dbs if db.strip()]

    max_open_files = int(subprocess.check_output(('sh', '-c', 'ulimit -n')))
    if max_open_files < 4096:
        print(('WARNING: Max number of open files is low (%d), it could\n' +
               'result in server errors. Consider running "ulimit -n 4096".')
              % max_open_files)

    if args.action == 'dump':
        dump(url, args.output_file, ignore_dbs=ignore_dbs)
    elif args.action == 'load':
        load(url, args.input_file, args.standalone_server,
             ignore_dbs=ignore_dbs)
    elif args.action == 'replicate':
        replicate_couchdb_server(args.source, url, ignore_dbs=ignore_dbs)
    else:
        parser.print_usage()
        parser.exit(1)


if __name__ == '__main__':
    main()
